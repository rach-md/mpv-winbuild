name: mpv
defaults:
  run:
    shell: bash

permissions:
  actions: write
  attestations: write
  contents: write

on: 
  workflow_dispatch:
    inputs:
      release:
        description: "Publish a release"
        required: false
        default: true
        type: boolean

jobs:
  build_mpv:
    name: Build mpv
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@main
        with:
          ref: main
      - name: Setup git config
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global pull.rebase true
          git config --global rebase.autoStash true
          git config --global fetch.prune true
      - name: Restore source cache
        uses: actions/cache/restore@main
        with:
          path: src_packages
          key: cached_source
      - name: Restore build cache
        uses: actions/cache/restore@main
        with:
          path: build
          key: cached_build
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install --no-install-recommends -y ccache nasm libmimalloc2.0
          pip install --user meson rst2pdf
          rustup update
          rustup target add x86_64-pc-windows-gnullvm
          mkdir -p llvm build/install
          url=$(curl -sL \
                     -H "Accept: application/vnd.github+json" \
                     -H "X-GitHub-Api-Version: 2022-11-28" \
                     https://api.github.com/repos/mstorsjo/llvm-mingw/releases/latest \
                     | jq -r '.assets[] | select(.browser_download_url | match("ucrt-ubuntu.*x86_64")) | .browser_download_url')
          echo "Downloading & installing llvm-mingw"
          curl -sLO $url && echo "llvm-mingw is successfully downloaded "
          filename=$(basename $url .tar.xz)
          tar -xJf $filename.tar.xz -C $PWD/llvm --strip-components=1 $filename/bin $filename/lib --exclude "aarch64*" --exclude "arm64ec*" --exclude "armv7*" &&
          tar -xJf $filename.tar.xz -C $PWD/build/install --strip-components=1 $filename/generic-w64-mingw32 $filename/x86_64-w64-mingw32 &&
          echo "llvm-mingw is successfully installed"
      - name: Build
        id: build
        run: |
          mkdir -p release

          cmake -Wno-dev --fresh -DTARGET_ARCH=x86_64-w64-mingw32 -DCOMPILER_TOOLCHAIN=clang -DCMAKE_INSTALL_PREFIX=$PWD/llvm -DMINGW_INSTALL_PREFIX=$PWD/build/install/x86_64-w64-mingw32 -DSINGLE_SOURCE_LOCATION=$PWD/src_packages -DRUST_LOCATION=$HOME -G Ninja -B $PWD/build -S $PWD

          ninja -C $PWD/build download || true
          ninja -C $PWD/build update
          ninja -C $PWD/build mpv-fullclean
          ninja -C $PWD/build mpv
          if [ -n "$(find $PWD/build -maxdepth 1 -type d -name "mpv" -print -quit)" ] ; then
              echo "Successfully compiled mpv. Continue"
          else
              echo "Failed compiled mpv. Stop"
              exit 1
          fi

          mv $PWD/build/mpv $PWD/release
          cd $PWD/release
          for dir in ./mpv; do
              if [ -d $dir ]; then
                  7z a -m0=lzma2 -mx=9 -ms=on mpv.7z $dir/* -x!*.7z
                  rm -rf $dir
              fi
          done
          cd ..
          sudo rm -rf $PWD/build/mpv
          sudo chmod -R a+rwx $PWD/build
      - name: Collect logs
        if: ${{ always() }}
        run: |
          sudo 7z a logs.7z $(find build -type f -iname "*-*.log" -or -wholename "*/ffbuild/config.log")
      - name: Upload logs
        uses: actions/upload-artifact@main
        if: ${{ always() }}
        with:
          name: logs
          path: logs.7z
      - name: Upload mpv
        uses: actions/upload-artifact@main
        with:
          name: mpv
          path: release/mpv.7z
      - name: Job summary
        uses: actions/github-script@main
        continue-on-error: true
        if: ${{ always() }}
        with:
          script: |
            const path = require('path');
            const { readdirSync,existsSync } = require('fs');
            const myExec = async (command, args = null) => await exec.getExecOutput(command,args,{silent: true}).then(result => result.stdout.trim()).catch(err => '');
            
            const rootdir = process.cwd();
            const workdir = path.resolve(rootdir,"src_packages");
            const isGitSync = dirname => existsSync(path.join(workdir, dirname, '.git'));
            
            const getGithubUrl = (hash,remote) => remote.replace(/\.git$/,"") + `/commit/${hash}`;
            function getCommitUrl(hash,remote) {
                let url = "";
                switch (true) {
                  case /github\.com/.test(remote):
                    url = getGithubUrl(hash,remote);
                    break;
                  default:
                    url = remote;
                    break;
                }
                return url;
            }
            async function repo_info(dir){
              let local_hash = await myExec(`git -C ${dir} rev-parse --short=7 HEAD`);
              let remote_branch = await myExec(`git -C ${dir} rev-parse --abbrev-ref HEAD@{upstream}`);
              let remote_hash = await myExec(`git -C ${dir} rev-parse ${remote_branch}`);
              let status = await myExec(`git -C ${dir} status -sb`).then(s => s.split("\n",1)[0].replace(/^## */,""));
              let remote = await myExec(`git -C ${dir} config --get remote.origin.url`);
              return [local_hash, remote_hash, status, remote]
            }
            
            async function generateGitInfoTable(targetDir){
              const dirs = readdirSync(targetDir, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory() && isGitSync(dirent.name) )
                .map(dirent => path.join(targetDir, dirent.name));
              let info_table = [[{data: 'Package', header: true}, {data: 'Local commit', header: true}, {data: 'Status', header: true}, {data: 'Remote commit', header: true}]];
              for (let dir of dirs) {
                [local_hash, remote_hash, status, remote] = await repo_info(dir)
                let url = getCommitUrl(remote_hash, remote);
                let package_name = path.basename(dir);
                info_table.push([package_name, local_hash, status, `<a href="${url}">${remote_hash.slice(0,7)}</a>`]);
              }
              return info_table;
            }

            await core.summary.clear();
            let packages_table = await generateGitInfoTable(workdir);
            packages_table = core.summary.addTable(packages_table).stringify();
            await core.summary.clear();
            
            const exec_path = path.join(rootdir,'build','exec');
            const clang_version = (await myExec(`${exec_path}`,["clang","--version"])).split('\n')[0];
            const rustc_version = (await myExec(`${exec_path}`,["rustc","--version"]));

            core.summary
              .addRaw(`Compiler:`,true)
              .addRaw(`${clang_version}`,true)
              .addRaw(`${rustc_version}`,true);
            await core.summary.addDetails('Packages Version',packages_table).write();
      - name: Delete previous source and build cache
        run : |
          curl -L \
          -X DELETE \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ github.token }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/repos/${{ github.repository }}/actions/caches?key=cached_source&ref=${{ github.ref }}"

          curl -L \
          -X DELETE \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ github.token }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/repos/${{ github.repository }}/actions/caches?key=cached_build&ref=${{ github.ref }}"
      - name: Save source cache
        uses: actions/cache/save@main
        with:
          path: src_packages
          key: cached_source
      - name: Save build cache
        uses: actions/cache/save@main
        with:
          path: build
          key: cached_build

  publish_release:
    name: Publish release
    needs: [build_mpv]
    if: ${{ inputs.release == true }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      attestations: write
      contents: write
    steps:
      - uses: actions/checkout@main
      - name: Download artifacts
        uses: actions/download-artifact@main
        with:
          path: artifacts
          pattern: 'mpv*'
      - name: Check artifacts
        uses: actions/github-script@main
        with:
          script: |
            const globber = await glob.create(`artifacts/mpv.7z`);
            const files = await globber.glob();
            if ( files.length == 0 ) {
              core.setFailed("Artifact does not exist!");
            }
      - name: Get current time
        run: |
          echo "long_time=$(date "+%Y-%m-%d %H:%M")" >> $GITHUB_ENV
      - name: Generate release note
        id: note
        uses: actions/github-script@main
        with:
          script: |
            let note = ``;
            note+="**Build Time**: ${{ env.long_time }}\n";
            note+="**Build Details**: https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}\n";
            core.setOutput("note",note);
      - name: Prepare release
        env:
          GH_TOKEN: ${{ github.token }}
        run:  |
          gh release delete mpv --cleanup-tag || true
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git tag mpv
      - name: Create release
        uses: ncipollo/release-action@main
        with:
          artifacts: "artifacts/mpv*.7z"
          name: "mpv"
          body: "${{ steps.note.outputs.note }}"
          tag: "mpv"
          allowUpdates: true
          artifactErrorsFailBuild: true
          prerelease: false
          makeLatest: true
      - name: Attest
        uses: actions/attest-build-provenance@main
        continue-on-error: true
        with:
          subject-path: 'artifacts/*.7z'
      - name: Prune old releases
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          git checkout main
          bash prunetags.sh
